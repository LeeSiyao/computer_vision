%% Explanation and reference
% This code attempts to count the number of blue rectangles (numA) and
% number of red squares (numB).
% https://www.mathworks.com/matlabcentral/answers/170457-how-to-implement-a-funtion-to-count-an-amount-of-one-type-of-lego-piece-in-the-image
%% procedure
% process the image and find the object boundary 
% Filter circular boundaries from boundaries
% produce color mask for both red and blue lego 
% Count the number of circles in the part where the color and the circle coincide
% use some restrictions to count the number of red lego and blue lego

%% Main function
function [NumA, NumB] = count_lego(I)
    I = im2double(I);
    [Bbw, ~] = createMaskB(I);
    [Rbw, ~] = createMaskR(I);
    % Further improve mask segmentation
    Bbw = refineSegment(Bbw);
    Rbw = refineSegment(Rbw);
%% Find out objects boundaries
    % first part of circle detection
    I = rgb2gray(I);
    w=fspecial('log', 18, 0.520); 
    If=imfilter(I,w,'replicate');
    % only keep the lowest values
    % they highlight the circles on the legos
    I1 = If < 0;
    I1 = imopen(I1, strel('disk', 2));  % remove the noise
    I1 = imclose(I1, strel('disk', 2));
    I1 = ~bwareaopen(~I1, 300);

    % Further processing of lines around objects
    I1 = imerode(I1, strel('disk', 2));
    I1 = imdilate(I1, strel('disk', 1));
    I1 = bwareaopen(I1, 155);

    % use boundaries label all regions
    [B, L] = bwboundaries(I1);
    %% Filter areas that contain circles
    % https://uk.mathworks.com/help/images/examples/identifying-round-objects.html
    circularityThresh = 0.52;
    stats = regionprops(L, 'Area', 'Centroid');
    circleRegion = [];
    % iterate through the regions in the original image
    % only keep those that are round enough
    % loop over the boundaries
    for k = 1:length(B)
      % obtain (X,Y) boundary coordinates corresponding to label 'k'
      boundary = B{k};
      % compute a simple estimate of the object's perimeter
      delta_sq = diff(boundary).^2;
      perimeter = sum(sqrt(sum(delta_sq,2)));
      % obtain the area corresponding to label 'k'
      area = stats(k).Area;
      % compute the roundness metric
      metric = 4*pi*area/perimeter^2;
      if metric > circularityThresh
        circleRegion = [circleRegion k];
      end
    end
    % only keep round regions
    % https://uk.mathworks.com/matlabcentral/fileexchange/25157-image-segmentation-tutorial
    I = ismember(L, circleRegion);

    NumA = countLegosBlue(I, Bbw);
    NumB = countLegosRed(I, Rbw);
end

%%  Further improve mask segmentation
function bw = refineSegment(bwmask)
    % https://uk.mathworks.com/matlabcentral/fileexchange/25157-image-segmentation-tutorial

    smallestAcceptableArea = 735;
	bwmask = bwareaopen(bwmask, smallestAcceptableArea);
	bwmask = imclose(bwmask, strel('disk', 5));
	l = logical(bwmask);
    bwmask = imfill(l, 'holes');
   
    % watershed segmentation
    % https://blog.csdn.net/wangqing_19900504/article/details/8230788
    % Further separate adjacent lego
    d1 = -bwdist(~bwmask);
    mask = imextendedmin(d1, 6);
    d2 = imimposemin(d1, mask);
    ld2 = watershed(d2);
    bwmask(ld2 == 0) = 0;
    
    bw = imerode(bwmask, strel('disk', 5));
  
end

%% create the mask for blue lego
function [BW,maskedRGBImage] = createMaskB(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 16-Dec-2020
%------------------------------------------------------


% Convert RGB image to chosen color space
I = rgb2hsv(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.564;
channel1Max = 0.649;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.403;
channel2Max = 1.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.184;
channel3Max = 0.865;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end

%% create mask for red lego
function [BW,maskedRGBImage] = createMaskR(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 16-Dec-2020
%------------------------------------------------------


% Convert RGB image to chosen color space
I = rgb2hsv(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.964;
channel1Max = 0.014;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.422;
channel2Max = 1.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.374;
channel3Max = 1.000;

% Create mask based on chosen histogram thresholds
sliderBW = ( (I(:,:,1) >= channel1Min) | (I(:,:,1) <= channel1Max) ) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end

%% count red lego
function legoCount = countLegosRed(image, mask)
    % Count the number of circles in the part where the color and the circle coincide
    [labelMask, holeCount] = bwlabel(mask);
    legoCount = 0;
    for i = 1:holeCount
        searchRegion = image & (labelMask == i);
        % count circles in this region
        [~, circleCount] = bwlabel(searchRegion);
        % When there are four holes(frontage) or one hole(the reverse side)
        % count this as a red lego 
        if circleCount ==1 || circleCount ==4 
            legoCount = legoCount + 1;
        end
    end
end

%% count blue lego
    function legoCount = countLegosBlue(image, mask)
   % Count the number of circles in the part where the color and the circle coincide
    [labeledMask, blobCount] = bwlabel(mask);
    legoCount = 0;
    for i = 1:blobCount
        searchRegion = image & (labeledMask == i);
        % count circles in this region
        [~, circleCount] = bwlabel(searchRegion);
        % when number of holes between three and eight 
        % count it as a blue lego
        if circleCount >=3 && circleCount <=8 
            legoCount = legoCount + 1;
        else
            % Some cases where two Legos are connected together 
            if (circleCount== 10 ||circleCount== 11)
            legoCount = legoCount + 2;
            end
        end
    end
end
